/*
 * Delta Forth .NET - World's first Forth compiler for the .NET platform
 * Copyright (C) 1997-2025 Valer BOCAN, PhD, CSSLP | www.bocan.ro
 *
 * GitHub Repository: https://github.com/vbocan/delta-forth
 */

using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using System.IO;
using DeltaForth.DataStructures;
using System.Collections.Generic;

namespace DeltaForth.Descriptors
{
    internal class ForthCodeGenerator
    {
        #region Local variables
        private AppDomain appDomain;            // Domain where we define the assemblies
        private AssemblyName assemblyName;      // AssemblyName
        private AssemblyBuilder assembly;       // Assembly
        private ModuleBuilder module;           // Module builder
        private TypeBuilder ForthEngineClass;   // DeltaForthEngine type

        private List<MethodBuilder> Methods;	// Metods defined in the class
        private CompilerMetadata MetaData;      // Compiler metadata (generated by the syntactic analyzer)        
        private MethodInfo StartupCode;         // Describes the pre-MAIN startup code
        private string TargetFileName;			// Name of the target file (no path information)
        private string TargetDirectory;         // Name of the target directory
        private bool bExe;                      // TRUE if generating code for EXE, FALSE for DLL
        private bool bCheckStack;               // TRUE if generating exception catching code for each method
        private bool bExtCallerDefined;         // TRUE if the runtime contains the ExternalCaller function
                                                // The function is generated in the runtime area at the first external call
        private MethodBuilder extCaller;		// ExternalCaller method builder
        #endregion

        #region Stacks
        private int ForthStackOrigin;           // The Forth stack origin
        private FieldBuilder ForthStack;        // The Forth stack
        private FieldBuilder ForthStackIndex;   // The Forth stack index
        private int ReturnStackOrigin;          // The return stack origin
        private FieldBuilder ReturnStack;       // The return stack
        private FieldBuilder ReturnStackIndex;  // The return stack index

        private int ForthStackSize;     // The Forth stack size
        private int ReturnStackSize;    // The Return stack size
        private int Tib;                // TIB area offset
        private int Pad;                // PAD area offset
        private int LocalVarArea;		// A maximum of 1024 local variables can be defined
        #endregion

        #region Temporary variables
        private FieldBuilder Dummy1;            // Dummy variable, used for temporary storage
        private FieldBuilder Dummy2;            // Dummy variable, used for temporary storage
        private FieldBuilder Dummy3;            // Dummy variable, used for temporary storage
        private FieldBuilder strDummy;          // Dummy variable, used for temporary storage
        private FieldBuilder DoLoopDummy;		// Dummy variable, used for Do-LOOP/+LOOP structure
        #endregion

        #region Write methods (used when generating code that displays text)
        private MethodInfo WriteStringMethod;       // Describes the Write(string) method
        private MethodInfo WriteLineStringMethod;   // Describes the WriteLine(string) method
        private MethodInfo WriteIntMethod;          // Describes the Write(int) method
        private MethodInfo WriteCharMethod;			// Describes the Write(char) method
        #endregion

        #region Control structures stacks        
        private Stack<IFDescriptor> IFStack;                // Stack for the IF-ELSE-THEN control structure
        private Stack<BEGINDescriptor> BEGINStack;		// Stack for the BEGIN-UNTIL control structure
        private Stack<Label> CASEStack;             // Stack for the CASE-ENDCASE control structure
        private Stack<DODescriptor> DOStack;                // Stack for the DO-LOOP/+LOOP control structure
        private Label CurrentMethodEndLabel;			// Label marking the end of the current method (for EXIT)
        #endregion

        public ForthCodeGenerator(CompilerMetadata MetaData, string TargetFileName, string TargetDirectory, string SignatureFileName, bool GenerateExecutable, bool GenerateStackFrames, int ForthStackSize, int ReturnStackSize)
        {
            // Initialize variables
            this.TargetFileName = TargetFileName;
            this.TargetDirectory = TargetDirectory;
            this.MetaData = MetaData;
            bExe = GenerateExecutable;
            bCheckStack = GenerateStackFrames;
            bExtCallerDefined = false;
            // Set stack sizes
            this.ForthStackSize = ForthStackSize;
            this.ReturnStackSize = ReturnStackSize;
            // Set system variables
            Tib = ForthStackSize - 64 - 80;
            Pad = ForthStackSize - 64;
            LocalVarArea = ForthStackSize - 64 - 80 - 1024;

            // Initialize stack origins
            ForthStackOrigin = 0;
            ReturnStackOrigin = 0;

            // Initialize Write methods
            WriteStringMethod = typeof(Console).GetMethod("Write", new Type[] { typeof(String) });
            WriteLineStringMethod = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(String) });
            WriteIntMethod = typeof(Console).GetMethod("Write", new Type[] { typeof(int) });
            WriteCharMethod = typeof(Console).GetMethod("Write", new Type[] { typeof(char) });

            // Initialize stacks
            IFStack = new Stack<IFDescriptor>();
            BEGINStack = new Stack<BEGINDescriptor>();
            CASEStack = new Stack<Label>();
            DOStack = new Stack<DODescriptor>();

            // Initialize address of global variables
            for (int i = 0; i < MetaData.GlobalVariables.Count; i++)
            {
                ForthVariable fv = MetaData.GlobalVariables[i];
                fv.Address = ForthStackOrigin;
                ForthStackOrigin += fv.Size;		// Advance the stack origin to accomodate the variable size
                MetaData.GlobalVariables[i] = fv;
            }

            Methods = new List<MethodBuilder>();
            // ...

            appDomain = Thread.GetDomain();             // Initialize domain

            assemblyName = new AssemblyName();          // Create an assembly name
            assemblyName.Name = "DeltaForthEngine";

            // Sign assembly (if the p_SignatureFileName parameter is not empty)
            if (SignatureFileName != string.Empty)
            {
                try
                {
                    FileStream fs = new FileStream(SignatureFileName, FileMode.Open);
                    StrongNameKeyPair kp = new StrongNameKeyPair(fs);
                    // The line below will throw an exception if the file does not
                    // contain a valid key
                    string PublicKey = kp.PublicKey.ToString();
                    fs.Close();
                    assemblyName.KeyPair = kp;
                }
                catch (FileNotFoundException)
                {
                    throw new Exception("Signature file " + SignatureFileName + " is missing.");
                }
                catch (Exception)
                {
                    throw new Exception("Signature file " + SignatureFileName + " is invalid.");
                }
            }

            // Create the assembly
#if NET48
			assembly = appDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Save, TargetDirectory);

			// Create a module within the assembly
			module = assembly.DefineDynamicModule("DeltaForthModule", TargetFileName);
#else
            // .NET Core/5+/10 doesn't support AssemblyBuilderAccess.Save
            // We use RunAndCollect for in-memory execution
            assembly = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndCollect);

            // Create a module within the assembly
            module = assembly.DefineDynamicModule("DeltaForthModule");
#endif

            // Define a public class
            var LibraryName = "DeltaForthEngine";   // Default class name
            if (!string.IsNullOrEmpty(MetaData.LibraryName)) LibraryName = MetaData.LibraryName;

            ForthEngineClass = module.DefineType(LibraryName, TypeAttributes.Public | TypeAttributes.BeforeFieldInit);

            // Create the class constructor
            Type[] constructorArgs = { };
            ConstructorBuilder constructor = ForthEngineClass.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, constructorArgs);

            // Create the method "InitForthEngine" to initialize the Forth environment
            StartupCode = CreateStartupCode();

            // Generate IL code for the constructor
            ILGenerator constructorIL = constructor.GetILGenerator();
            constructorIL.Emit(OpCodes.Ldarg_0);
            ConstructorInfo superConstructor = typeof(Object).GetConstructor(new Type[0]);
            constructorIL.Emit(OpCodes.Call, superConstructor);
            constructorIL.Emit(OpCodes.Ret);
        }

        // CreateStartupCode - Creates a function that initializes the Forth stack, the return stack, system variables, etc.
        // Input:  None
        // Output: A MethodBuilder structure describing the pre-MAIN start-up code
        private MethodBuilder CreateStartupCode()
        {
            // Initialize the Forth stack
            ForthStack = ForthEngineClass.DefineField("ForthStack", typeof(int[]), FieldAttributes.Public | FieldAttributes.Static);
            ForthStackIndex = ForthEngineClass.DefineField("ForthStackIndex", typeof(int), FieldAttributes.Public | FieldAttributes.Static);
            // Initialize the return stack
            ReturnStack = ForthEngineClass.DefineField("ReturnStack", typeof(int[]), FieldAttributes.Private | FieldAttributes.Static);
            ReturnStackIndex = ForthEngineClass.DefineField("ReturnStackIndex", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            // Initialize dummy fields
            Dummy1 = ForthEngineClass.DefineField("dummy1", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            Dummy2 = ForthEngineClass.DefineField("dummy2", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            Dummy3 = ForthEngineClass.DefineField("dummy3", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            strDummy = ForthEngineClass.DefineField("strdummy", typeof(string), FieldAttributes.Private | FieldAttributes.Static);
            DoLoopDummy = ForthEngineClass.DefineField("dummy4", typeof(int), FieldAttributes.Private | FieldAttributes.Static);
            // Create the InitEngine method
            MethodBuilder InitMethod = ForthEngineClass.DefineMethod("InitEngine", MethodAttributes.Private | MethodAttributes.Static, typeof(void), null);
            ILGenerator ilgen = InitMethod.GetILGenerator();
            // Initialize ForthStack array
            ilgen.Emit(OpCodes.Ldc_I4, ForthStackSize);
            ilgen.Emit(OpCodes.Newarr, typeof(int));    // Was "int[]". Thanks to Brad Merrill from Microsoft.
            ilgen.Emit(OpCodes.Stsfld, ForthStack);
            // Initialize ReturnStack array
            ilgen.Emit(OpCodes.Ldc_I4, ReturnStackSize);
            ilgen.Emit(OpCodes.Newarr, typeof(int));    // Was "int[]". Thanks to Brad Merrill from Microsoft.
            ilgen.Emit(OpCodes.Stsfld, ReturnStack);
            // Initialize ForthStackIndex to origin
            ilgen.Emit(OpCodes.Ldc_I4, ForthStackOrigin);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            // Normal return from function
            ilgen.Emit(OpCodes.Ret);

            return InitMethod;
        }
        // SetEntryPoint - Sets the starting point of the program
        // Input:  The name of the method that starts the program
        // Output: None
        private void SetEntryPoint(string MethodName)
        {
#if NET48
			// Setup program entry point (MAIN code)
			MethodInfo entrypoint = GetMethod(MethodName).GetBaseDefinition();
			if(entrypoint == null)	// No MAIN function defined
			{
				entrypoint = StartupCode;	// Execution begins with the startup code
			}
			assembly.SetEntryPoint(entrypoint, PEFileKinds.ConsoleApplication);
			// NOTE:
			// DF versions prior to 1.0 beta 2b used the line below to set up the entry point
			// of the DLL. With the advent of the .NET Framework RC, this technique didn't work
			// any more, since a DLL initialization exception occurs at runtime.
			//assembly.SetEntryPoint(entrypoint, PEFileKinds.Dll);
#else
            // .NET Core/5+/10: Entry point setting is not applicable for in-memory assemblies
            // This would only be needed for persisted assemblies
#endif
        }

        // AddMethod - Builds a method and adds it to the DeltaForthEngine class
        // Input:  MethodName - the name of the method
        // Output: A MethodBuilder structure
        private MethodBuilder AddMethod(string MethodName)
        {
            MethodBuilder ForthMethod = ForthEngineClass.DefineMethod(MethodName, MethodAttributes.Public | MethodAttributes.Static, typeof(void), null);
            Methods.Add(ForthMethod);   // Add method builder to our list
            return ForthMethod;
        }

        // GetMethod - Gets the information for a specified method
        // Input:  MethodName - the name of the method
        // Output: A MethodBuilder structure
        private MethodBuilder GetMethod(string MethodName)
        {
            return Methods.Find(m => m.Name.ToUpper() == MethodName.ToUpper());
        }

        // DoGenerateCode - Generates code out of available words
        // Input:  None
        // Output: None
        public void DoGenerateCode()
        {
            // Add all words to the module
            foreach (var word in MetaData.Words)
            {
                AddMethod(word.Name);
            }

            // Generate the code for each method (Forth word)
            foreach (var word in MetaData.Words)
            {
                MethodBuilder mb = GetMethod(word.Name);
                GenerateMethodCode(mb);
            }

            // Create the assembly
            CreateAssembly();
        }

        // CreateAssembly - Creates the compiled type from the generated IL code
        // Input:  None
        // Output: The compiled Type
        public Type CreateAssembly()
        {
            // Finalize and return the type
            return ForthEngineClass.CreateType();
        }

        // GenerateMethodCode - Generate the code of the specified method
        // Input:  None
        // Output: None
        private void GenerateMethodCode(MethodBuilder mb)
        {
            string MethodName = mb.Name;
            ILGenerator MethodILGen = mb.GetILGenerator();

            // Define the end label for this method (used by EXIT)
            CurrentMethodEndLabel = MethodILGen.DefineLabel();

            // Initialize address of local variables for the current method
            for (int i = 0; i < MetaData.LocalVariables.Count; i++)
            {
                ForthLocalVariable fv = MetaData.LocalVariables[i];
                if (fv.WordName == MethodName)
                {
                    fv.Address = LocalVarArea + i;
                    MetaData.LocalVariables[i] = fv;
                }
            }

            // If we are generating code for the MAIN function, we should call the startup code first
            if (MethodName == "MAIN")
            {
                MethodILGen.Emit(OpCodes.Call, StartupCode);
            }

            // Each method should catch exceptions thrown by stack operations
            if (bCheckStack) MethodILGen.BeginExceptionBlock();

            // We have the method name, now look for the contents of the word
            List<string> WordContents = MetaData.Words.Find(w => w.Name.ToUpper() == MethodName.ToUpper()).Definition;

            // The contents of the 'MethodName' word is now in the 'WordContents' list
            foreach (string at in WordContents)
            {
                // Get the current atom
                string atom = at;

                // Display statement ( ."<text>" )
                if (atom.StartsWith(".\""))
                {
                    atom = atom.Remove(0, 2);                       // Remove ."
                    atom = atom.TrimEnd(new char[] { '\"' });           // Remove trailing "
                    MethodILGen.Emit(OpCodes.Ldstr, atom);              // ldstr "text"
                    MethodILGen.Emit(OpCodes.Call, WriteStringMethod);  // call WriteLine(string)
                    continue;
                }

                // Dump statement ( "<text>")
                if (atom.StartsWith("\""))
                {
                    atom = atom.Trim(new char[] { '\"' });          // Remove " from the beginning and the end of the string
                    _Dump(MethodILGen, atom);               // Dump the string at the address specified on the stack
                    continue;
                }

                switch (atom)
                {
                    case "+":   // "+" - adds two numbers on the stack
                        MathOp(MethodILGen, '+');
                        break;
                    case "-":   // "-" - adds two numbers on the stack
                        MathOp(MethodILGen, '-');
                        break;
                    case "*":   // "*" - adds two numbers on the stack
                        MathOp(MethodILGen, '*');
                        break;
                    case "/":   // "/" - adds two numbers on the stack
                        MathOp(MethodILGen, '/');
                        break;
                    case "MOD": // "MOD" - division remainder
                        MathOp(MethodILGen, '%');
                        break;
                    case "/MOD": // "Slash MOD" - division remainder and result
                        _SlashMod(MethodILGen);
                        break;
                    case "*/": // "Star Slash" - scaling operator
                        _StarSlash(MethodILGen);
                        break;
                    case "*/MOD": // "Star Slash Mod" - scaling operator
                        _StarSlashMod(MethodILGen);
                        break;
                    case "MINUS": // "Minus" - minus
                        _Minus(MethodILGen);
                        break;
                    case "ABS":  // "Absolute" - absolute value
                        _Abs(MethodILGen);
                        break;
                    case "MIN": // "MIN" - minimum of two values
                        _MinMax(MethodILGen, true);
                        break;
                    case "MAX": // "MAX" - maximum of two values
                        _MinMax(MethodILGen, false);
                        break;
                    case "1+":  // "One Plus" - adds 1 to the value on top of stack
                        _OnePlus(MethodILGen);
                        break;
                    case "2+":  // "Two Plus" - adds 2 to the value on top of stack
                        _TwoPlus(MethodILGen);
                        break;
                    case "0=":  // "Zero Equal" - test for equality with 0
                        _ZeroEqual(MethodILGen);
                        break;
                    case "0<":  // "Zero Less" - test for 0 or less
                        _ZeroLess(MethodILGen);
                        break;
                    case "=":   // "Equal" - test for equal
                        _Equal(MethodILGen);
                        break;
                    case "<":   // "Less" - test for less
                        _Less(MethodILGen);
                        break;
                    case ">":   // "Greater" - test for greater
                        _Greater(MethodILGen);
                        break;
                    case "<>":  // "Not equal" - test for not-equal
                        _NotEqual(MethodILGen);
                        break;
                    case "~AND":    // Bitwise AND
                        _BitwiseOp(MethodILGen, '&');
                        break;
                    case "~OR":     // Bitwise OR
                        _BitwiseOp(MethodILGen, '|');
                        break;
                    case "~XOR":    // Bitwise XOR
                        _BitwiseOp(MethodILGen, '^');
                        break;
                    case "~NOT":    // Bitwise NOT
                        _BitwiseNOT(MethodILGen);
                        break;
                    case "AND":     // Logical AND
                        _LogicalAND(MethodILGen);
                        break;
                    case "OR":      // Logical OR
                        _LogicalOR(MethodILGen);
                        break;
                    case "NOT":     // Logical NOT
                        _LogicalNOT(MethodILGen);
                        break;
                    case "DUP":     // Duplicates the value on top of stack
                        _Dup(MethodILGen);
                        break;
                    case "-DUP":    // Duplicates the value on top of stack unless it is 0
                        _DashDup(MethodILGen);
                        break;
                    case "DROP":    // Removes the value on top of stack
                        _Drop(MethodILGen);
                        break;
                    case "SWAP":    // Swaps the topmost two values on the stack
                        _Swap(MethodILGen);
                        break;
                    case "OVER":    // Duplicates the second value on the stack
                        _Over(MethodILGen);
                        break;
                    case "ROT":     // Rotates top three elements on the stack
                        _Rot(MethodILGen);
                        break;
                    case "SP@":     // Stack pointer fetch
                        _SPfetch(MethodILGen);
                        break;
                    case "RP@":     // Return stack pointer fetch
                        _RPfetch(MethodILGen);
                        break;
                    case "SP!":     // Flush Forth stack
                        _SPstore(MethodILGen);
                        break;
                    case "RP!":     // Flush return stack
                        _RPstore(MethodILGen);
                        break;
                    case "@":       // Fetch
                        _Fetch(MethodILGen);
                        break;
                    case "?":       // Question-mark
                        _QuestionMark(MethodILGen);
                        break;
                    case "!":       // Store
                        _Store(MethodILGen);
                        break;
                    case "+!":      // Plus store
                        _PlusStore(MethodILGen);
                        break;
                    case "EMIT":    // Emit
                        _Emit(MethodILGen);
                        break;
                    case ".":
                        // October 18, 2003
                        // Added stack bounds verification for the . word
                        if (bCheckStack)
                        {
                            Label lb1 = MethodILGen.DefineLabel();
                            MethodILGen.Emit(OpCodes.Ldsfld, ForthStackIndex);
                            MethodILGen.Emit(OpCodes.Ldc_I4, ForthStackOrigin);
                            MethodILGen.Emit(OpCodes.Bgt_S, lb1);
                            // Throw exception (stack underflow)
                            MethodILGen.ThrowException(typeof(System.IndexOutOfRangeException));
                            MethodILGen.MarkLabel(lb1);
                        }
                        MethodILGen.Emit(OpCodes.Ldsfld, ForthStack);
                        MethodILGen.Emit(OpCodes.Ldsfld, ForthStackIndex);
                        MethodILGen.Emit(OpCodes.Ldc_I4_1);
                        MethodILGen.Emit(OpCodes.Sub);
                        MethodILGen.Emit(OpCodes.Dup);
                        MethodILGen.Emit(OpCodes.Stsfld, ForthStackIndex);
                        MethodILGen.Emit(OpCodes.Ldelem_I4);
                        MethodILGen.Emit(OpCodes.Call, WriteIntMethod); // call WriteLine(int)
                        break;
                    case "CR":  // CR - moves the cursor to the beginning of the next line
                        MethodILGen.Emit(OpCodes.Ldstr, "");                // ldstr ""
                        MethodILGen.Emit(OpCodes.Call, WriteLineStringMethod);  // call WriteLine(string)
                        break;
                    case "SPACE":   // SPACE - displays an empty space on the screen
                        MethodILGen.Emit(OpCodes.Ldstr, " ");               // ldstr " "
                        MethodILGen.Emit(OpCodes.Call, WriteStringMethod);  // call WriteLine(string)
                        break;
                    case "SPACES":  // SPACES - displays a number of space on the screen
                        _Spaces(MethodILGen);
                        break;
                    case "TYPE":    // TYPE - Types a text on the screen
                        _Type(MethodILGen);
                        break;
                    case "PAD":     // PAD - 64-cell area
                        _Pad(MethodILGen);
                        break;
                    case "TIB":     // TIB - 80-cell area
                        _Tib(MethodILGen);
                        break;
                    case "S0":      // Forth stack origin
                        _StackOrigin(MethodILGen, true);
                        break;
                    case "R0":      // Return stack origin
                        _StackOrigin(MethodILGen, false);
                        break;
                    case "KEY":     // KEY - Places the key code on the stack
                        _Key(MethodILGen);
                        break;
                    case "EXPECT":
                        _Expect(MethodILGen);
                        break;
                    case "QUERY":
                        _Query(MethodILGen);
                        break;
                    case ">R":
                        _ToR(MethodILGen);
                        break;
                    case "R>":
                        _RFrom(MethodILGen);
                        break;
                    case "I":
                        _I(MethodILGen);
                        break;
                    case "I'":
                        _Isecond(MethodILGen);
                        break;
                    case "J":
                        _J(MethodILGen);
                        break;
                    case "FILL":
                        _Fill(MethodILGen);
                        break;
                    case "ERASE":
                        _Erase(MethodILGen, 0);
                        break;
                    case "BLANKS":
                        _Erase(MethodILGen, 32);
                        break;
                    case "STR2INT":
                        _Str2Int(MethodILGen);
                        break;
                    case "COUNT":
                        _Count(MethodILGen);
                        break;
                    case "CMOVE":
                        _CMove(MethodILGen);
                        break;
                    case "INT2STR":
                        _Int2Str(MethodILGen);
                        break;
                    case "EXIT":
                        _Exit(MethodILGen);
                        break;
                    case "IF":
                        _If(MethodILGen);
                        break;
                    case "ELSE":
                        _Else(MethodILGen);
                        break;
                    case "THEN":
                        _Then(MethodILGen);
                        break;
                    case "BEGIN":
                        _Begin(MethodILGen);
                        break;
                    case "UNTIL":
                        _Until(MethodILGen);
                        break;
                    case "AGAIN":
                        _Again(MethodILGen);
                        break;
                    case "WHILE":
                        _While(MethodILGen);
                        break;
                    case "REPEAT":
                        _Repeat(MethodILGen);
                        break;
                    case "CASE":
                        _Case(MethodILGen);
                        break;
                    case "OF":
                        _Of(MethodILGen);
                        break;
                    case "ENDOF":
                        _EndOf(MethodILGen);
                        break;
                    case "ENDCASE":
                        _EndCase(MethodILGen);
                        break;
                    case "DO":
                        _Do(MethodILGen);
                        break;
                    case "LEAVE":
                        _Leave(MethodILGen);
                        break;
                    case "LOOP":
                        _Loop(MethodILGen);
                        break;
                    case "+LOOP":
                        _PlusLoop(MethodILGen);
                        break;
                    default:
                        try
                        {
                            // Try to push the atom onto the stack (hoping that it is a number)
                            _PushStack(MethodILGen, Convert.ToInt32(atom, 10));
                            break;
                        }
                        catch (Exception)
                        {
                            // It's not a number, swallow the error and continue checking
                        }

                        // Check whether the atom is a constant
                        var GlobalConstant = MetaData.GlobalConstants.Find(c => c.Name.ToUpper() == atom);
                        if (GlobalConstant != null)
                        {
                            if (GlobalConstant.Value.GetType() == typeof(int))
                            {
                                // The constant is of integer type
                                _PushStack(MethodILGen, (int)GlobalConstant.Value);
                            }
                            else
                            {
                                // The constant is of string type
                                _Dump(MethodILGen, (string)GlobalConstant.Value);
                            }
                            break;
                        }

                        // Check whether the atom is a local variable
                        var LocalVar = MetaData.LocalVariables.Find(v => v.Name.ToUpper() == atom && v.WordName.ToUpper() == MethodName);
                        if (LocalVar != null)
                        {
                            string varaddr = LocalVar.Address.ToString();
                            _PushStack(MethodILGen, Convert.ToInt32(varaddr, 10));
                            break;
                        }

                        // Check whether the atom is a variable
                        var GlobalVar = MetaData.GlobalVariables.Find(v => v.Name.ToUpper() == atom);
                        if (GlobalVar != null)
                        {
                            string varaddr = GlobalVar.Address.ToString();
                            _PushStack(MethodILGen, Convert.ToInt32(varaddr, 10));
                            break;
                        }

                        // Check whether the atom is an external word
                        var ExternalWord = MetaData.ExternalWords.Find(v => v.Name.ToUpper() == atom);
                        if (ExternalWord != null)
                        {
                            CallExternalMethod(MethodILGen, ExternalWord.Library, ExternalWord.Class, ExternalWord.Method);
                            break;
                        }

                        // Finally, if it's not a known word, then raise and error
                        MethodBuilder lmb = GetMethod(atom);
                        if (lmb != null)
                        {
                            // It must be a word we're dealing with
                            MethodILGen.Emit(OpCodes.Call, GetMethod(atom));    // Call function
                        }
                        else
                        {
                            throw new Exception(atom + " in word " + MethodName + " is not known.");
                        }
                        break;
                }

            }
            // Catch the index out of bounds exception
            if (bCheckStack)
            {
                MethodILGen.BeginCatchBlock(typeof(IndexOutOfRangeException));
                MethodILGen.Emit(OpCodes.Pop);
                // If exception occured in MAIN, simply display an error message and return
                if (MethodName == "MAIN")
                {
                    MethodILGen.EmitWriteLine("RUNTIME ERROR: Stack underflow or overflow.");
                }
                else
                {
                    // If the exception occured in some method, rethrow the exception to MAIN
                    MethodILGen.ThrowException(typeof(IndexOutOfRangeException));
                }

                // Catch the file not found exception (thrown by ExternalCaller)
                MethodILGen.BeginCatchBlock(typeof(System.IO.FileNotFoundException));
                MethodILGen.Emit(OpCodes.Pop);
                MethodILGen.EmitWriteLine("RUNTIME ERROR: Library file not found.");
                MethodILGen.EndExceptionBlock();
            }

            // Mark the end label (EXIT branches here)
            MethodILGen.MarkLabel(CurrentMethodEndLabel);

            // Every function ends with the RET statement
            MethodILGen.Emit(OpCodes.Ret);
        }

        // MathOp - Generates code for operations +, -, *, /
        // 		ForthStack[ForthStackIndex - 2] = ForthStack[ForthStackIndex - 2] "MathOp" ForthStack[ForthStackIndex - 1];
        //		ForthStackIndex--;
        // Input:  ILGenerator for the method, operation to perform
        // Output: None
        private void MathOp(ILGenerator ilgen, char Op)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            // -------------------------
            switch (Op)
            {
                case '+':
                    ilgen.Emit(OpCodes.Add);
                    break;
                case '-':
                    ilgen.Emit(OpCodes.Sub);
                    break;
                case '*':
                    ilgen.Emit(OpCodes.Mul);
                    break;
                case '/':
                    ilgen.Emit(OpCodes.Div);
                    break;
                case '%':
                    ilgen.Emit(OpCodes.Rem);
                    break;

            }
            // -------------------------
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _PushStack - Push a value on the stack
        //		ForthStack[ForthStackIndex++] = "value";
        // Input:  ILGenerator for the method, value to push
        // Output: None
        private void _PushStack(ILGenerator ilgen, int value)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, value);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _SlashMod - Division remainder and result
        //		Dummy1 = ForthStack[ForthStackIndex - 1];
        //		Dummy2 = ForthStack[ForthStackIndex - 2];
        //		ForthStack[ForthStackIndex - 2] = Dummy2 % Dummy1;
        //		ForthStack[ForthStackIndex - 1] = Dummy2 / Dummy1;
        // Input:  ILGenerator for the method
        // Output: None
        private void _SlashMod(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Rem);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Div);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _StarSlash - Scaling operator
        //		Dummy1 = ForthStack[ForthStackIndex - 1];
        //		Dummy2 = ForthStack[ForthStackIndex - 2];
        //		Dummy3 = ForthStack[ForthStackIndex - 3];
        //		ForthStackIndex-=2;
        //		ForthStack[ForthStackIndex - 1] = Dummy3 * Dummy2 / Dummy1;
        // Input:  ILGenerator for the method
        // Output: None
        private void _StarSlash(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Mul);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Div);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _StarSlashMod - Scaling operator
        //		Dummy1 = ForthStack[ForthStackIndex - 1];
        //		Dummy2 = ForthStack[ForthStackIndex - 2];
        //		Dummy3 = ForthStack[ForthStackIndex - 3];
        //		ForthStackIndex--;
        //		ForthStack[ForthStackIndex - 2] = (Dummy3 * Dummy2) % Dummy1;
        //		ForthStack[ForthStackIndex - 1] = Dummy3 * Dummy2 / Dummy1;
        // Input:  ILGenerator for the method
        // Output: None
        private void _StarSlashMod(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Mul);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Rem);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Mul);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Div);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Minus - Changes the sign of the number on top of stack
        //		ForthStack[ForthStackIndex - 1] = - ForthStack[ForthStackIndex - 1];
        // Input:  ILGenerator for the method
        // Output: None
        private void _Minus(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Neg);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Abs - Absolute value of number
        //
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = Math.Abs(ForthStack[ForthStackIndex - 1]);
        // Output: None
        private void _Abs(ILGenerator ilgen)
        {
            MethodInfo Abs = typeof(Math).GetMethod("Abs", new Type[] { typeof(int) });

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Call, Abs);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _MinMax - Minimum and maximum value
        //
        // Input:  ILGenerator for the method
        //			Minimum - true if minimum is to calculated, false for maximum
        //		ForthStack[ForthStackIndex - 1] = Math.Min(ForthStack[ForthStackIndex - 1]);
        //		ForthStackIndex--;
        // Output: None
        private void _MinMax(ILGenerator ilgen, bool Minimum)
        {
            MethodInfo Min = typeof(Math).GetMethod("Min", new Type[] { typeof(int), typeof(int) });
            MethodInfo Max = typeof(Math).GetMethod("Max", new Type[] { typeof(int), typeof(int) });

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            if (Minimum)
                ilgen.Emit(OpCodes.Call, Min);
            else
                ilgen.Emit(OpCodes.Call, Max);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _OnePlus - Adds 1 to the value on top of stack
        //
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = ForthStack[ForthStackIndex - 1] + 1;
        // Output: None
        private void _OnePlus(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _TwoPlus - Adds 2 to the value on top of stack
        //
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = ForthStack[ForthStackIndex - 1] + 2;
        // Output: None
        private void _TwoPlus(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _ZeroEqual - Test for "zero-equal"
        //
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = (ForthStack[ForthStackIndex - 1] == 0) ? 1 : 0;
        // Output: None
        private void _ZeroEqual(ILGenerator ilgen)
        {
            Label lbZero = ilgen.DefineLabel();
            Label lbOne = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);

            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse_S, lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lbZero);
            ilgen.MarkLabel(lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lbZero);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _ZeroLess - Test for "zero or less"
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = (ForthStack[ForthStackIndex - 1] <= 0) ? 1 : 0;
        // Output: None
        private void _ZeroLess(ILGenerator ilgen)
        {
            Label lbZero = ilgen.DefineLabel();
            Label lbOne = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Ble_S, lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lbZero);
            ilgen.MarkLabel(lbOne);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lbZero);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Equal - Test for "equal"
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 1] == ForthStack[ForthStackIndex - 2]) ? 1 : 0;
        //		ForthStackIndex--;
        // Output: None
        private void _Equal(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Beq_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Less - Test for "less"
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 2] < ForthStack[ForthStackIndex - 1]) ? 1 : 0;
        //		ForthStackIndex--;
        // Output: None
        private void _Less(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Blt_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Greater - Test for "greater"
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 2] > ForthStack[ForthStackIndex - 1]) ? 1 : 0;
        //		ForthStackIndex--;
        // Output: None
        private void _Greater(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Bgt_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _NotEqual - Test for "not equal"
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = (ForthStack[ForthStackIndex - 2] <> ForthStack[ForthStackIndex - 1]) ? 1 : 0;
        //		ForthStackIndex--;
        // Output: None
        private void _NotEqual(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Bne_Un_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _BitwiseOp - Bitwise operations (AND, OR, XOR)
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = ForthStack[ForthStackIndex - 2] "op" ForthStack[ForthStackIndex - 1];
        //		ForthStackIndex--;
        // Output: None
        private void _BitwiseOp(ILGenerator ilgen, char Op)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            switch (Op)
            {
                case '&':
                    ilgen.Emit(OpCodes.And);
                    break;
                case '|':
                    ilgen.Emit(OpCodes.Or);
                    break;
                case '^':
                    ilgen.Emit(OpCodes.Xor);
                    break;
            }
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _BitwiseNOT - Bitwise NOT
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = ~ForthStack[ForthStackIndex - 1];
        // Output: None
        private void _BitwiseNOT(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Not);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _LogicalAND - Logical AND
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = ((ForthStack[ForthStackIndex - 2] > 0) && (ForthStack[ForthStackIndex - 1] > 0) ? 1 : 0);
        //		ForthStackIndex--;
        // Output: None
        private void _LogicalAND(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();
            Label lb3 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Ble_S, lb1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb3);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb3);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _LogicalOR - Logical OR
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 2] = ((ForthStack[ForthStackIndex - 2] > 0) || (ForthStack[ForthStackIndex - 1] > 0) ? 1 : 0);
        //		ForthStackIndex--;
        // Output: None
        private void _LogicalOR(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();
            Label lb3 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _LogicalNOT - Logical NOT
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex - 1] = (ForthStack[ForthStackIndex - 1] != 0) ? 0 : 1;
        // Output: None
        private void _LogicalNOT(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brtrue_S, lb1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Br_S, lb2);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Dup - Duplicates the element on top of stack
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex] = ForthStack[ForthStackIndex - 1];
        //		ForthStackIndex++;
        // Output: None
        private void _Dup(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _DashDup - Duplicates the element on top of stack unless it is 0
        // Input:  ILGenerator for the method
        //		if(ForthStack[ForthStackIndex - 1] != 0) ForthStack[ForthStackIndex] = ForthStack[ForthStackIndex - 1];
        //		ForthStackIndex++;
        // Output: None
        private void _DashDup(ILGenerator ilgen)
        {
            Label lb = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse_S, lb);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.MarkLabel(lb);
            ilgen.Emit(OpCodes.Nop);
        }

        // _Drop - Removes the element on top of stack
        // Input:  ILGenerator for the method
        //		ForthStackIndex--;
        // Output: None
        private void _Drop(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Swap - Swaps the two elements on the top of stack
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 1];
        //		ForthStack[ForthStackIndex - 1] = ForthStack[ForthStackIndex - 2];
        //		ForthStack[ForthStackIndex - 2] = Dummy1;
        // Output: None
        private void _Swap(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Over - Duplicates the second value on the stack
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex] = ForthStack[ForthStackIndex - 2];
        //		ForthStackIndex++;
        // Output: None
        private void _Over(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Rot
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 3];
        //		ForthStack[ForthStackIndex - 3] = ForthStack[ForthStackIndex - 2];
        //		ForthStack[ForthStackIndex - 2] = ForthStack[ForthStackIndex - 1];
        //		ForthStack[ForthStackIndex - 1] = Dummy1;
        // Output: None
        private void _Rot(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _SPfetch - Current Forth stack index
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex] = ForthStackIndex;
        //		ForthStackIndex++;
        // Output: None
        private void _SPfetch(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _RPfetch - Current return stack index
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex] = ReturnStackIndex;
        //		ForthStackIndex++;
        // Output: None
        private void _RPfetch(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _SPstore - Flush Forth stack
        // Input:  ILGenerator for the method
        //		ForthStackIndex = ForthStackOrigin;
        // Output: None
        private void _SPstore(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldc_I4, ForthStackOrigin);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _RPstore - Flush return stack
        // Input:  ILGenerator for the method
        //		ForthStackIndex = ReturnStackOrigin;
        // Output: None
        private void _RPstore(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldc_I4, ReturnStackOrigin);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Fetch - Fetch the value from a given address
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 1];
        //		ForthStack[ForthStackIndex - 1] = ForthStack[Dummy1];
        // Output: None
        private void _Fetch(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _QuestionMark - Display the value from a given address
        // Input:  ILGenerator for the method
        //		Console.Write(ForthStack[ForthStack[--ForthStackIndex]]);
        // Output: None
        private void _QuestionMark(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Call, WriteIntMethod);
        }

        // _Store - Stores a value at a given address
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 2];
        //		Dummy2 = ForthStack[ForthStackIndex - 1];
        //		ForthStack[Dummy2] = Dummy1;
        //		ForthStackIndex -= 2;
        // Output: None
        private void _Store(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _PlusStore - Adds a value at a given address
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 2];
        //		Dummy2 = ForthStack[ForthStackIndex - 1];
        //		ForthStack[Dummy2] += Dummy1;
        //		ForthStackIndex -= 2;
        // Output: None
        private void _PlusStore(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Emit - Prints a char with the specified code
        // Input:  ILGenerator for the method
        //		Console.Write((char)ForthStack[--ForthStackIndex]);
        // Output: None
        private void _Emit(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Conv_U2);
            ilgen.Emit(OpCodes.Call, WriteCharMethod);
        }

        // _Spaces - Prints a series of spaces
        // Input:  ILGenerator for the method
        //		for(Dummy1 = 0; Dummy1 < ForthStack[--ForthStackIndex]; Dummy1++) Console.Write(' ');
        // Output: None
        private void _Spaces(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldc_I4_S, 32);
            ilgen.Emit(OpCodes.Call, WriteCharMethod);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Blt_S, lb2);
        }

        // _Type - Types a text
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 2];
        //		Dummy2 = ForthStack[ForthStackIndex - 1];
        //		for(Dummy3 = Dummy1; Dummy3 < Dummy1 + Dummy2; Dummy3++) Console.Write((char)ForthStack[Dummy3]);
        //		ForthStackIndex -= 2;
        // Output: None
        private void _Type(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Conv_U2);
            ilgen.Emit(OpCodes.Call, WriteCharMethod);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Blt_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
        }

        // _Pad - Pointer to a 64-cell area
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = Pad;
        // Output: None
        private void _Pad(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, Pad);    // PAD is at the end of the Forth stack
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Tib - Pointer to a 80-cell area
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = Tib;
        // Output: None
        private void _Tib(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, Tib);    // TIB is before the PAD area
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _StackOrigin - Forth stack and return stack origin
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = "ForthStackOrigin | ReturnStackOrigin";
        // Output: None
        private void _StackOrigin(ILGenerator ilgen, bool bForthStack)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            if (bForthStack)
                ilgen.Emit(OpCodes.Ldc_I4, ForthStackOrigin);
            else
                ilgen.Emit(OpCodes.Ldc_I4, ReturnStackOrigin);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Key - Places on the stack the code of the key pressed
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = Console.Read();		
        // Output: None
        private void _Key(ILGenerator ilgen)
        {
            MethodInfo ReadCharMethod = typeof(Console).GetMethod("Read");
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Call, ReadCharMethod);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Expect - Awaits characters and places them on the stack
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[--ForthStackIndex];	// Max number of characters
        //		Dummy2 = ForthStack[--ForthStackIndex];	// Address
        //		while(Dummy1 > 0)
        //		{
        //			Dummy3 = Console.Read();
        //			if(Dummy3 == 13) 
        //			{
        //				ForthStack[Dummy2++] = 0;
        //				break;
        //			}
        //			ForthStack[Dummy2++] = Dummy3;
        //			Dummy1--;
        //		}
        // Output: None
        private void _Expect(ILGenerator ilgen)
        {
            MethodInfo ReadCharMethod = typeof(Console).GetMethod("Read");
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();
            Label lb3 = ilgen.DefineLabel();
            Label lb4 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb4);
            ilgen.Emit(OpCodes.Call, ReadCharMethod);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldc_I4, 13);
            ilgen.Emit(OpCodes.Bne_Un_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br_S, lb3);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb4);
            ilgen.MarkLabel(lb3);
        }

        // _Query - Awaits 80 characters at the TIB area
        // Input:  ILGenerator for the method
        //		Dummy1 = 80;	// Max number of characters
        //		Dummy2 = Tib;	// Address
        //		while(Dummy1 > 0)
        //		{
        //			Dummy3 = Console.Read();
        //			if(Dummy3 == 10) 
        //			{
        //				ForthStack[Dummy2++] = 0;
        //				break;
        //			}
        //			ForthStack[Dummy2++] = Dummy3;
        //			Dummy1--;
        //		}
        // Output: None
        private void _Query(ILGenerator ilgen)
        {
            // QUERY reads a line of input from the console into TIB (Terminal Input Buffer)
            // and leaves the TIB address on the stack
            // Maximum 80 characters are read

            MethodInfo ReadLineMethod = typeof(Console).GetMethod("ReadLine", Type.EmptyTypes);
            Label skipWrite = ilgen.DefineLabel();

            // Read a line from console
            ilgen.Emit(OpCodes.Call, ReadLineMethod);  // string s = Console.ReadLine();
            ilgen.Emit(OpCodes.Stsfld, strDummy);      // strDummy = s;

            // Check if null (EOF)
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Brfalse, skipWrite);    // if (s == null) skip

            // Copy string to TIB character by character
            ilgen.Emit(OpCodes.Ldc_I4_0);              // int i = 0;
            ilgen.Emit(OpCodes.Stsfld, Dummy1);        // Dummy1 = i (loop counter)
            ilgen.Emit(OpCodes.Ldc_I4, Tib);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);        // Dummy2 = TIB address

            Label loopStart = ilgen.DefineLabel();
            Label loopEnd = ilgen.DefineLabel();

            // Loop: while (i < s.Length && i < 80)
            ilgen.MarkLabel(loopStart);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetProperty("Length").GetGetMethod());
            ilgen.Emit(OpCodes.Bge, loopEnd);          // if (i >= s.Length) break;

            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_S, 80);
            ilgen.Emit(OpCodes.Bge, loopEnd);          // if (i >= 80) break;

            // TIB[i] = (int)s[i];
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetProperty("Chars").GetGetMethod());
            ilgen.Emit(OpCodes.Conv_I4);
            ilgen.Emit(OpCodes.Stelem_I4);

            // i++; TIB address++
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);

            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);

            ilgen.Emit(OpCodes.Br, loopStart);

            // End loop - add null terminator
            ilgen.MarkLabel(loopEnd);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);

            // Skip write if ReadLine returned null
            ilgen.MarkLabel(skipWrite);

            // Push TIB address onto Forth stack
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4, Tib);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _ToR - Transfers the element to the top of the return stack
        // Input:  ILGenerator for the method
        //		ReturnStack[ReturnStackIndex++] = ForthStack[--ForthStackIndex];
        // Output: None
        private void _ToR(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _RFrom - Transfers the element from the return stack to the forth stack
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = ReturnStack[--ReturnStackIndex];
        // Output: None
        private void _RFrom(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _I - Copies the top element from the return stack to the Forth stack
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = ReturnStack[ReturnStackIndex - 1];
        // Output: None
        private void _I(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Isecond - Copies the second top element from the return stack to the Forth stack
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = ReturnStack[ReturnStackIndex - 2];
        // Output: None
        private void _Isecond(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _J - Copies the third top element from the return stack to the Forth stack
        // Input:  ILGenerator for the method
        //		ForthStack[ForthStackIndex++] = ReturnStack[ReturnStackIndex - 3];
        // Output: None
        private void _J(ILGenerator ilgen)
        {
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Fill - Fills an area
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 1];	// c
        //		Dummy2 = ForthStack[ForthStackIndex - 2];	// n
        //		Dummy3 = ForthStack[ForthStackIndex - 3];	// addr
        //		ForthStackIndex -= 3;
        //		while(Dummy2-- > 0)
        //		{
        //			ForthStack[Dummy3++] = Dummy1;
        //		}
        // Output: None
        private void _Fill(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_3);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
        }

        // _Erase - Fills an area
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[ForthStackIndex - 1];	// n
        //		Dummy2 = ForthStack[ForthStackIndex - 2];	// addr
        //		ForthStackIndex -= 2;
        //		while(Dummy1-- > 0)
        //		{
        //			ForthStack[Dummy2++] = "Value"; // 0 or 32
        //		}
        // Output: None
        private void _Erase(ILGenerator ilgen, int FillValue)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4, FillValue);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
        }

        // _Str2Int - Converts a string from TIB to a number on the stack
        // Input:  ILGenerator for the method
        //		Dummy1 = Tib;
        //		strDummy = "";
        //		while(ForthStack[Dummy1] != 0) 
        //		{	
        //			strDummy += (char)ForthStack[Dummy1];
        //			Dummy1++;
        //		}
        //		ForthStack[ForthStackIndex++] = Convert.ToInt32(strDummy);
        // Output: None
        private void _Str2Int(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();
            Label exc = ilgen.DefineLabel();

            ilgen.BeginExceptionBlock();
            ilgen.Emit(OpCodes.Ldc_I4, Tib);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldstr, "");
            ilgen.Emit(OpCodes.Stsfld, strDummy);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Conv_U2);
            ilgen.Emit(OpCodes.Box, typeof(char));
            ilgen.Emit(OpCodes.Call, typeof(string).GetMethod("Concat", new Type[] { typeof(Object), typeof(Object) }));
            ilgen.Emit(OpCodes.Stsfld, strDummy);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brtrue_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Call, typeof(Convert).GetMethod("ToInt32", new Type[] { typeof(string) }));
            ilgen.Emit(OpCodes.Stelem_I4);

            ilgen.BeginCatchBlock(typeof(FormatException));
            ilgen.EmitWriteLine("RUNTIME ERROR: Could not interpret the TIB area.");
            ilgen.Emit(OpCodes.Pop);
            // Use Leave to exit the exception block and branch to method end
            // Cannot use Ret directly from inside exception handler
            ilgen.Emit(OpCodes.Leave, CurrentMethodEndLabel);
            ilgen.EndExceptionBlock();
        }

        // _Count - Counts the number of non-zero consecutive characters
        // Input:  ILGenerator for the method
        //		Dummy1 = Tib;
        //		strDummy = "";
        //		while(ForthStack[Dummy1] != 0) 
        //		{	
        //			strDummy += (char)ForthStack[Dummy1];
        //			Dummy1++;
        //		}
        //		ForthStack[ForthStackIndex++] = Convert.ToInt32(strDummy);
        // Output: None
        private void _Count(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brtrue_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Dump - Dumps a string on the stack
        // Input:  ILGenerator for the method, string to dump on the stack
        //		Dummy1 = ForthStack[--ForthStackIndex];		// Address
        //		Dummy2 = strDummy.Length;
        //		Dummy3 = 0;
        //		while(Dummy2-- > 0)
        //		{
        //			ForthStack[Dummy1++] = strDummy[Dummy3++];
        //		}
        //		ForthStack[Dummy1] = 0;		
        // Output: None
        private void _Dump(ILGenerator ilgen, string text)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldstr, text);
            ilgen.Emit(OpCodes.Stsfld, strDummy);

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Length"));
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Chars", new Type[] { typeof(int) }));
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _CMove - Dumps a string on the stack
        // Input:  ILGenerator for the method
        //		Dummy1 = ForthStack[--ForthStackIndex];	// Count
        //		Dummy2 = ForthStack[--ForthStackIndex];	// Destination
        //		Dummy3 = ForthStack[--ForthStackIndex];	// Source
        //		while(Dummy1-- > 0) ForthStack[Dummy2++] = ForthStack[Dummy3++];		
        // Output: None
        private void _CMove(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
        }

        // _Int2Str	- Converts an integer on the stack to a string
        // Input:  ILGenerator for the method
        //		strDummy = (ForthStack[--ForthStackIndex]).ToString();	// Value to convert
        //		Dummy1 = ForthStack[--ForthStackIndex];		// Address
        //		Dummy2 = strDummy.Length;
        //		Dummy3 = 0;
        //		while(Dummy2-- > 0)
        //		{
        //			ForthStack[Dummy1++] = strDummy[Dummy3++];
        //		}
        //		ForthStack[Dummy1] = 0;
        // Output: None
        private void _Int2Str(ILGenerator ilgen)
        {
            Label lb1 = ilgen.DefineLabel();
            Label lb2 = ilgen.DefineLabel();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelema, typeof(System.Int32));
            ilgen.Emit(OpCodes.Call, typeof(System.Int32).GetMethod("ToString", new Type[] { }));
            ilgen.Emit(OpCodes.Stsfld, strDummy);

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Length"));
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Br_S, lb1);
            ilgen.MarkLabel(lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldsfld, strDummy);
            ilgen.Emit(OpCodes.Ldsfld, Dummy3);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stsfld, Dummy3);
            ilgen.Emit(OpCodes.Callvirt, typeof(string).GetMethod("get_Chars", new Type[] { typeof(int) }));
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.MarkLabel(lb1);
            ilgen.Emit(OpCodes.Ldsfld, Dummy2);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, Dummy2);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Bgt_S, lb2);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, Dummy1);
            ilgen.Emit(OpCodes.Ldc_I4_0);
            ilgen.Emit(OpCodes.Stelem_I4);
        }

        // _Exit	- Exits from the current word
        // Input:  ILGenerator for the method
        // Output: None
        private void _Exit(ILGenerator ilgen)
        {
            // Clean up all active DO loops (they use the return stack)
            int doLoopCount = DOStack.Count;
            if (doLoopCount > 0)
            {
                // Each DO loop puts 2 values on the return stack (limit and index)
                // We need to remove all of them: count * 2
                int cleanupCount = doLoopCount * 2;
                ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
                // Use the appropriate opcode based on the value
                switch (cleanupCount)
                {
                    case 1: ilgen.Emit(OpCodes.Ldc_I4_1); break;
                    case 2: ilgen.Emit(OpCodes.Ldc_I4_2); break;
                    case 3: ilgen.Emit(OpCodes.Ldc_I4_3); break;
                    case 4: ilgen.Emit(OpCodes.Ldc_I4_4); break;
                    case 5: ilgen.Emit(OpCodes.Ldc_I4_5); break;
                    case 6: ilgen.Emit(OpCodes.Ldc_I4_6); break;
                    case 7: ilgen.Emit(OpCodes.Ldc_I4_7); break;
                    case 8: ilgen.Emit(OpCodes.Ldc_I4_8); break;
                    default: ilgen.Emit(OpCodes.Ldc_I4, cleanupCount); break;
                }
                ilgen.Emit(OpCodes.Sub);
                ilgen.Emit(OpCodes.Stsfld, ReturnStackIndex);
            }

            // Use Leave instead of Br to properly exit exception blocks
            // Leave is like Br but works across exception block boundaries
            ilgen.Emit(OpCodes.Leave, CurrentMethodEndLabel);
        }

        // _If - Processes the IF atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _If(ILGenerator ilgen)
        {
            IFDescriptor sIF = new IFDescriptor { lbElse = ilgen.DefineLabel(), lbEnd = ilgen.DefineLabel(), bElse = false };

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse, sIF.lbElse);

            IFStack.Push(sIF);
        }

        // _Else - Processes the ELSE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Else(ILGenerator ilgen)
        {
            IFDescriptor sIF = IFStack.Pop();

            ilgen.Emit(OpCodes.Br, sIF.lbEnd);  // Avoid executing the False branch
            ilgen.MarkLabel(sIF.lbElse);
            sIF.bElse = true;

            IFStack.Push(sIF);
        }

        // _Then - Processes the THEN atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Then(ILGenerator ilgen)
        {
            IFDescriptor sIF = IFStack.Pop();

            ilgen.MarkLabel(sIF.lbEnd);
            if (sIF.bElse == false) ilgen.MarkLabel(sIF.lbElse);
        }

        // _Begin - Processes the BEGIN atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Begin(ILGenerator ilgen)
        {
            BEGINDescriptor sBEGIN = new BEGINDescriptor { lbBegin = ilgen.DefineLabel(), lbEnd = ilgen.DefineLabel() };
            ilgen.MarkLabel(sBEGIN.lbBegin);
            BEGINStack.Push(sBEGIN);
        }

        // _Until - Processes the UNTIL atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Until(ILGenerator ilgen)
        {
            BEGINDescriptor sBEGIN = BEGINStack.Pop();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse, sBEGIN.lbBegin);
        }

        // _Again - Processes the AGAIN atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Again(ILGenerator ilgen)
        {
            BEGINDescriptor sBEGIN = BEGINStack.Pop();
            ilgen.Emit(OpCodes.Br, sBEGIN.lbBegin);
        }

        // _While - Processes the WHILE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _While(ILGenerator ilgen)
        {
            BEGINDescriptor sBEGIN = BEGINStack.Peek();

            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Brfalse, sBEGIN.lbEnd);
        }

        // _Repeat - Processes the REPEAT atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Repeat(ILGenerator ilgen)
        {
            BEGINDescriptor sBEGIN = BEGINStack.Pop();
            ilgen.Emit(OpCodes.Br, sBEGIN.lbBegin);
            ilgen.MarkLabel(sBEGIN.lbEnd);
        }

        // _Case - Processes the CASE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Case(ILGenerator ilgen)
        {
            Label lbEndCase = ilgen.DefineLabel();
            CASEStack.Push(lbEndCase);
        }

        // _Of - Processes the OF atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Of(ILGenerator ilgen)
        {
            Label lbEndOf = ilgen.DefineLabel();
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Bne_Un, lbEndOf);
            CASEStack.Push(lbEndOf);
        }

        // _EndOf - Processes the OF atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _EndOf(ILGenerator ilgen)
        {
            Label lbEndOf = CASEStack.Pop();
            Label lbEndCase = CASEStack.Pop();
            ilgen.Emit(OpCodes.Br, lbEndCase);
            ilgen.MarkLabel(lbEndOf);
            CASEStack.Push(lbEndCase);
        }

        // _EndCase - Processes the ENDCASE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _EndCase(ILGenerator ilgen)
        {
            Label lbEndCase = CASEStack.Pop();
            ilgen.MarkLabel(lbEndCase);
            _Drop(ilgen);
        }

        // _Do - Processes the DO atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Do(ILGenerator ilgen)
        {
            DODescriptor sDO = new DODescriptor { lbDo = ilgen.DefineLabel(), lbLoop = ilgen.DefineLabel() };
            _Swap(ilgen);
            _ToR(ilgen);
            _ToR(ilgen);
            ilgen.MarkLabel(sDO.lbDo);
            DOStack.Push(sDO);
        }

        // _Leave - Processes the LEAVE atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Leave(ILGenerator ilgen)
        {
            DODescriptor sDO = DOStack.Peek();
            // Clean up 2 elements from the return stack
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ReturnStackIndex);

            ilgen.Emit(OpCodes.Br, sDO.lbLoop);
        }

        // _Loop - Processes the LOOP atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _Loop(ILGenerator ilgen)
        {
            DODescriptor sDO = DOStack.Peek();
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            // The two following lines of code have been added in order to correct the behavior of the DO-LOOP structure which did not exit early enough
            // Ex. 5 0 DO I . LOOP; should print 01234 instead of 012345 as it was previously
            // Valer BOCAN, October 26, 2011
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            // End of change
            ilgen.Emit(OpCodes.Bge_S, sDO.lbLoop);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, DoLoopDummy);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br, sDO.lbDo);
            ilgen.MarkLabel(sDO.lbLoop);
            // Clean up 2 elements from the return stack
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ReturnStackIndex);

            DOStack.Pop();
        }

        // _PlusLoop - Processes the +LOOP atom
        // Input:  ILGenerator for the method
        // Output: None
        private void _PlusLoop(ILGenerator ilgen)
        {
            DODescriptor sDO = DOStack.Peek();
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Stsfld, DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldelem_I4);
            // Valer BOCAN, October 26, 2011 (see explanation from the LOOP)
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            // End of change
            ilgen.Emit(OpCodes.Bge_S, sDO.lbLoop);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStack);
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Ldsfld, DoLoopDummy);
            ilgen.Emit(OpCodes.Ldsfld, ForthStack);
            ilgen.Emit(OpCodes.Ldsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_1);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Dup);
            ilgen.Emit(OpCodes.Stsfld, ForthStackIndex);
            ilgen.Emit(OpCodes.Ldelem_I4);
            ilgen.Emit(OpCodes.Add);
            ilgen.Emit(OpCodes.Stelem_I4);
            ilgen.Emit(OpCodes.Br, sDO.lbDo);
            ilgen.MarkLabel(sDO.lbLoop);
            // Clean up 2 elements from the return stack
            ilgen.Emit(OpCodes.Ldsfld, ReturnStackIndex);
            ilgen.Emit(OpCodes.Ldc_I4_2);
            ilgen.Emit(OpCodes.Sub);
            ilgen.Emit(OpCodes.Stsfld, ReturnStackIndex);

            DOStack.Pop();
        }

        // CallExternalMethod - Calls a method from a class in an external file
        // Input:  ILGenerator for the method
        //			FileName - the name of the file containing the class
        //			ClassName - the name of the class
        //			MethodName - the name of the method to call
        // Output: None
        private void CallExternalMethod(ILGenerator ilgen, string FileName, string ClassName, string MethodName)
        {
            if (!bExtCallerDefined)
            {
                // The runtime does not contain the ExternalCaller function, we add it here
                // Function ExternalCaller
                Type[] parameters = { typeof(String) /* FileName */, typeof(String) /* ClassName */, typeof(String) /* MethodName */ };
                extCaller = ForthEngineClass.DefineMethod("ExternalCaller", MethodAttributes.Private | MethodAttributes.Static, typeof(void), parameters);
                // Field calAssembly
                FieldBuilder calAssembly = ForthEngineClass.DefineField("CalleeAssembly", typeof(System.Reflection.Assembly), FieldAttributes.Private | FieldAttributes.Static);
                // Field calType
                FieldBuilder calType = ForthEngineClass.DefineField("CalleeType", typeof(System.Type), FieldAttributes.Private | FieldAttributes.Static);
                // Field calMethodInfo
                FieldBuilder calMethodInfo = ForthEngineClass.DefineField("CalleeMethodInfo", typeof(System.Reflection.MethodInfo), FieldAttributes.Private | FieldAttributes.Static);
                // Field calInstance
                FieldBuilder calInstance = ForthEngineClass.DefineField("CalleeInstance", typeof(System.Object), FieldAttributes.Private | FieldAttributes.Static);

                ILGenerator extCallerILGen = extCaller.GetILGenerator();

                // Define a few local labels
                Label lb1 = extCallerILGen.DefineLabel();
                Label lb2 = extCallerILGen.DefineLabel();
                Label lb3 = extCallerILGen.DefineLabel();
                Label lb4 = extCallerILGen.DefineLabel();
                Label lb5 = extCallerILGen.DefineLabel();

                extCallerILGen.BeginExceptionBlock();
                extCallerILGen.Emit(OpCodes.Ldarg_0);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Reflection.Assembly).GetMethod("LoadFrom", new Type[] { typeof(String) }));
                extCallerILGen.Emit(OpCodes.Stsfld, calAssembly);
                extCallerILGen.Emit(OpCodes.Ldsfld, calAssembly);
                extCallerILGen.Emit(OpCodes.Ldarg_1);
                extCallerILGen.Emit(OpCodes.Ldc_I4_0);
                extCallerILGen.Emit(OpCodes.Ldc_I4_1);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.Assembly).GetMethod("GetType", new Type[] { typeof(String), typeof(bool), typeof(bool) }));
                extCallerILGen.Emit(OpCodes.Stsfld, calType);
                extCallerILGen.Emit(OpCodes.Ldsfld, calType);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Type).GetMethod("op_Equality", new Type[] { typeof(System.Type), typeof(System.Type) }));
                extCallerILGen.Emit(OpCodes.Brfalse_S, lb1);
                extCallerILGen.EmitWriteLine("\n\rRUNTIME ERROR: Could not load library.");
                extCallerILGen.Emit(OpCodes.Br_S, lb2);
                extCallerILGen.MarkLabel(lb1);
                extCallerILGen.Emit(OpCodes.Ldsfld, calType);
                extCallerILGen.Emit(OpCodes.Ldarg_2);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Type).GetMethod("GetMethod", new Type[] { typeof(String) }));
                extCallerILGen.Emit(OpCodes.Stsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Reflection.MethodInfo).GetMethod("op_Equality", new Type[] { typeof(System.Reflection.MethodInfo), typeof(System.Reflection.MethodInfo) }));
                extCallerILGen.Emit(OpCodes.Brfalse_S, lb3);
                extCallerILGen.EmitWriteLine("\n\rRUNTIME ERROR: Could not call external method.");
                extCallerILGen.Emit(OpCodes.Br_S, lb2);
                extCallerILGen.MarkLabel(lb3);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.MethodBase).GetMethod("get_IsStatic", new Type[] { }));
                extCallerILGen.Emit(OpCodes.Brtrue_S, lb4);
                extCallerILGen.Emit(OpCodes.Ldsfld, calType);
                extCallerILGen.Emit(OpCodes.Call, typeof(System.Activator).GetMethod("CreateInstance", new Type[] { typeof(System.Type) }));
                extCallerILGen.Emit(OpCodes.Stloc_0);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldloc_0);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.MethodBase).GetMethod("Invoke", new Type[] { typeof(Object), typeof(Object[]) }));
                extCallerILGen.Emit(OpCodes.Pop);
                extCallerILGen.Emit(OpCodes.Br_S, lb2);
                extCallerILGen.MarkLabel(lb4);
                extCallerILGen.Emit(OpCodes.Ldsfld, calMethodInfo);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Ldnull);
                extCallerILGen.Emit(OpCodes.Callvirt, typeof(System.Reflection.MethodBase).GetMethod("Invoke", new Type[] { typeof(Object), typeof(Object[]) }));
                extCallerILGen.Emit(OpCodes.Pop);
                extCallerILGen.MarkLabel(lb2);
                extCallerILGen.Emit(OpCodes.Leave_S, lb5);
                extCallerILGen.Emit(OpCodes.Pop);
                extCallerILGen.BeginCatchBlock(typeof(System.IO.FileNotFoundException));
                extCallerILGen.ThrowException(typeof(System.IO.FileNotFoundException));
                extCallerILGen.EndExceptionBlock();
                extCallerILGen.MarkLabel(lb5);
                extCallerILGen.Emit(OpCodes.Ret);

                bExtCallerDefined = true;
            }

            // ExternalCaller method is already defined in runtime, we just call it
            ilgen.Emit(OpCodes.Ldstr, FileName);
            ilgen.Emit(OpCodes.Ldstr, ClassName);
            ilgen.Emit(OpCodes.Ldstr, MethodName);
            ilgen.Emit(OpCodes.Call, extCaller);
        }
    }

}
